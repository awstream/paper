\begin{table*}
  \small
  \centering
  \begin{tabular}{ c r l }
    \toprule
    \multirow{5}{*}{Normal Operators}
    & \textit{map} (f: I $\Rightarrow$ O) & Stream<I> $\Rightarrow$ Stream<O> \\
    & \textit{skip} (i: Integer) & Stream<I> $\Rightarrow$
                                   Stream<I> \\
    & \textit{sliding\_window} (count: Integer, f: Vec<I> $\Rightarrow$ O) & Stream<I> $\Rightarrow$
                                                                            Stream<O> \\
    % & \textit{tumbling\_window} (count: Integer, f: Vec<I> $\Rightarrow$ O) & Stream<I> $\Rightarrow$
    %                                                                          Stream<O> \\
    & \textit{timed\_window} (time: Duration, f: Vec<I> $\Rightarrow$ O) & Stream<I> $\Rightarrow$
                                                                          Stream<O> \\
    & ... & ... \\
    \midrule
    \multirow{5}{*}{Degradation Operators}
    & \textit{maybe} (knobs: Vec<T>, f:  (T, I) $\Rightarrow$ I) & Stream<I> $\Rightarrow$
                                                                 Stream<I> \\
    & \textit{maybe\_skip} (knobs: Vec<Integer>) & Stream<I> $\Rightarrow$ Stream<I> \\
    & \textit{maybe\_head} (knobs: Vec<Integer>) & Stream<Vec<I>{}> $\Rightarrow$
                                                   Stream<Vec<I>{}> \\
    & \textit{maybe\_downsample} (knobs: Vec<(Integer, Interger)>) & Stream<Image> $\Rightarrow$ Stream<Image> \\
    & ... & ... \\
    \bottomrule
  \end{tabular}
  \caption{Stream processing operators in \sysname{}. \texttt{Vec<T>} represents
    a list of elements with type \texttt{T}.}
  \label{tab:operators}
\end{table*}

\subsection{APIs for Structured Adaptation}
\label{sec:struct-adapt}

%% Introduce graphs of operators model
The majority of stream processing applications today are constructed as a
directed graph of operators~\cite{toshniwal2014storm, zaharia2013discretized},
where each operator transforms input streams into new streams. \sysname{}
borrows the same computation model. We list some example operators, such as
\texttt{map} and \texttt{skip}, in \autoref{tab:operators}.

Along with normal operators, \sysname{} integrates special \maybe{} operators
that degrades the data quality, yielding potential bandwidth savings. Our design
has the following goals: (i) to free developers from specifying exact rules, the
API should tolerate approximate specifications; (ii) to allow combining multiple
dimensions, the API should be modular: each operator is a unit and developer can
chain multiple operators; (iii) to support flexible integration with arbitrary
degradation functions, the API should take user-defined functions
(UDFs). Therefore, our API is,
\vspace{-2pt}
\begin{lstlisting}
        maybe(knobs: Vec<T>, f: (T, I) => I)
\end{lstlisting}

We illustrate the usage of \texttt{maybe} operator with an example that
quantizes a stream of integers in Rust:

\vspace{-2pt}
\begin{lstlisting}
    let quantized_stream = vec![1, 2, 3, 4].into_stream()
        .maybe(vec![2, 4], |k, p| p.wrapping_div(k));
        .collect();
\end{lstlisting}

The snippet creates a stream of integers, chains a degradation operation and
collects the execution result. In this example, the knob is [2, 4], and the
degradation function performs a wrapping (modular) division where the divisor is
the chosen knob. The knob value modifies the quantization level, affecting the
output: [1, 2, 3, 4] (no degradation), [0, 1, 1, 2] (k=2), or [0, 0, 0, 1]
(k=4). If the stream is subsequently encoded---for example, run-length encoding
as in JPEG~\cite{wallace1992jpeg}---for transmission, the bandwidth consumption
will change according to the level of degradation.

Based on the \texttt{maybe} primitive, one can implement wrappers of degradation
operations for common data types. For instance, \texttt{maybe\_head} will
optionally takes the top values of the \textit{list}; and
\texttt{maybe\_downsample} can adjust the \textit{image} resolution to a
configured target. \sysname{} provides a few such operations as libraries for
developers (\autoref{tab:operators}).

With our APIs, the example mentioned in \autoref{sec:making-case-sys-approach}
can now be implemented as follows:

\vspace{-2pt}
\begin{lstlisting}[caption={Video Processing Example}, label={lst:ex}]
   let app = Camera::new((1920, 1080, 30))
      .maybe_downsample(vec![(1600, 900), (1280, 720)])
      .maybe_skip(vec![2, 5])
      .map(|frame| frame.show())
      .compose();
\end{lstlisting}

This snippet first instantiates a \texttt{Camera} source, which produces
\texttt{Stream<Image>} with 1920x1080 resolution and 30 FPS. Two degradation
operations follow the source: one that downsamples image to either 1600x900 or
1280x720 resolution; one that skips frames with a parameter of 2 or 5, resulting
in 30/(2+1)=10 FPS or 30/(5+1)= 6 FPS. In this example, degraded images are
shown on the display, while in practice, further processing, such as encoding
and transmission, operators can be chained.

Structured adaptation not only simplifies the specifications of degradation, the
structure also facilitates learning an accurate profile
(\autoref{sec:automatic-profiling}) and reacting at runtime
(\autoref{sec:runtime}).

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "sosp17"
%%% End:
