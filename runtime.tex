\subsection{Runtime Adaptation and Resource Allocation}
\label{sec:runtime}

At runtime, \sysname{} performs application adaptation according to the learn
profile. \autoref{fig:runtime} shows our runtime system architecture with
application logic and additional modules from \sysname{}.

\fixme{Why a new runtime?} TCP is rate adaptive; but it applications.  video
streaming based on the current level of the playback buffer : cite A
Buffer-Based Approach to Rate Adaptation: Evidence from a Large Video Streaming
Service. Current practice adjusts the estimation based on the buffer occupancy.

\sysname{} applications' source contains a \texttt{Maybe} module derived from
all \maybe{} operations. This module allows controller to \textit{update} the
level of degradation. Data generated by the source is then enqueued to
\texttt{Queue} and subsequently dequeued by \texttt{Socket}. When data
generation rate exceeds \texttt{Socket}'s departure rate, the queue grows. At
this time, the adaptation controller (AC) queries the estimated bandwidth from
\texttt{Socket} and regulates the source stream by updating the configuration.
After the data is sent through the network, the receiver extracts raw data to
the online profiler and delivers data to the application analytics.
\fixme{Perhaps need to make clear here that the raw data is sent only when the
  queue is drained? Is that how it works?} When a new profile is learned, it's
fed back to AC for subsequent adaptation.

We then focus on the adaptation algorithm (\autoref{fig:cc}). AC receives
messages from \texttt{Queue} and \texttt{Socket}. We denote messages with the
sender's name as the prefix, e.g., \texttt{Queue} and \texttt{Q.NoQueue}. AC
loads the learned the profile and sorts all configurations with an ascending
order of bandwidth consumption. The current configuration is $c_i$ and
configurations that have the least and most bandwidth demand are $c_1$ and
$c_{max}$, respectively. AC's algorithm is a state machine:

\para{Startup: rapid growth.} When the application starts up, it uses $c_1$ and
performs its first and most rapid rate increase. Upon each \texttt{Q.NoQueue}
message, it advances the configuration from $c_i$ to $c_{i+1}$, increasing the
data rate discretely. The growth stops if it receives \texttt{Q.Congestion}
(turning into \texttt{Degrade} state) or $c_{i+1} = c_{max}$ (entering
\texttt{Steady} state).

\para{Degrade: reacting to congestion.} The application enters this state upon
receiving \texttt{Q.Congestion}, meaning there are queued objects in
\texttt{Queue}. AC queries the current delivery rate $R$ from \texttt{Socket}
and updates \texttt{Degrade} with configuration $c$ such that $B(c) < \alpha R$,
$\alpha \in (0, 1)$. A smaller $\alpha$ allows a quicker draining of the
queue. After the queue is drained, AC receives \texttt{Q.NoQueue} message and
enters \texttt{Steady} state.

\begin{figure}
  \centering
  % \resizebox{\columnwidth}{!}{
  %   \input{runtime-diagram}
  % }
  \includegraphics[width=\linewidth]{figures/runtime-adaptation.pdf}
  \caption{Runtime adaptation system architecture.}
  \label{fig:runtime}
\end{figure}

\para{Steady: low latency delivery.} Applications achieve low latency by
spending most of the time in \texttt{Steady} state. If the network condition
changes and the delivery bandwidth is not sufficient, the queue will grow. Once
the queue length exceeds a threshold, the \texttt{Q.Congestion} signal will
change the state to \texttt{Degrade}. After the application stays in
\texttt{Steady} state for a while, if $c_i < c_{max}$, AC will enter
\texttt{Probe} state to check for more available bandwidth.

\para{Probe: more bandwidth for a higher accuracy.} Advancing $c_i$ directly may
cause drastic latency increase when $B(c_{i+1}) \gg B(c_i)$. To allow a
fine-grain probing, \texttt{Socket} sends additional traffic controlled by
\texttt{probe\_gain} (similar to the probing in BBR~\cite{cardwell2017bbr}).  AC
stops \texttt{Probe} and returns to \texttt{Steady} under two conditions: (1)
the available bandwidth $R$ is large enough for the next configuration, i.e.,
$B(c_{i+1}) < R$ (receiving \texttt{S.ProbeDone} message); (2) objects are
queued due to the probing traffic (receiving \texttt{Q.Congestion}).

\begin{figure}
  \begin{subfigure}[t]{\columnwidth}
    \centering
    \includegraphics[width=\columnwidth]{figures/cc.pdf}
    \caption{Rate Adaptation State Machine}
    \vspace{1em}
    \label{fig:cc-sm}
  \end{subfigure}
  \begin{subfigure}[t]{0.9\columnwidth}
    \centering
    \includegraphics[width=\columnwidth]{figures/cc2.pdf}
    \caption{An example to illustrate the adaptation algorithm.}
    \label{fig:cc-ex}
  \end{subfigure}

  \caption{The Adaptation algorithm as a state machine and an illustration of
    one possible trace showing state transitions.}
  \label{fig:cc}
\end{figure}

% \begin{figure}
%   \centering
%   \resizebox{\columnwidth}{!}{
%     \input{congestion-control}
%   }
%   \caption{Congestion Control Algorithm}
%   \label{fig:cc}
% \end{figure}

\vspace{1em}\noindent \fixme{Refine allocation story.}. \textbf{Resource
  allocation:} The learned profile is also useful to control network resource
allocation; this are extremely useful in the wide-area where the bandwidth is
precious or there is a budget constrain. For a single stream, developers can set
a maximal allowed data rate. For multiple streams, the profiles allow
\textit{utility fairness} in addition to resource fairness. We elaborate on the
multiple streams (multitask) scenario below.

Traditional resource fairness (such as TCP converges to a equal share of the
bandwidth) among competing flows if they share the bottleneck link.

%% However, resource fairness is different from utility fairness. Consider two
%% profiles.  An allocation of X, Y leads to 0.3 and 0.7 accuracy; while another
%% allocation could achieve 0.6 and 0.6 accuracy.

We formulate the allocation as the following optimization problem: the
congestion controller finds an allocation $c_i^t$ to maximize the
\textit{minimal} application accuracy among all running tasks, subject to that
the total bandwidth demand does not exceed available bandwidth
(\autoref{eq:multitask}).

\begin{equation}
  \label{eq:multitask}
  \begin{aligned}
    & \underset{c_i^t}{\text{maximize}} & & \min({A^t(c_i^t)}) & & \\
    & \text{subject to} & & \sum_t{B^t(c_i^t)} < R & & \\
  \end{aligned}
\end{equation}

Solving this optimization is NP hard. In practice, we use a greedy approach for
the allocation.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "sosp17"
%%% End:
