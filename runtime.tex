\subsection{Runtime Adaptation}
\label{sec:runtime}

\begin{figure}
  \centering
  \resizebox{\columnwidth}{!}{
    \input{runtime-diagram}
  }
  % \includegraphics[width=\linewidth]{figures/runtime-adaptation.pdf}
  \caption{Runtime adaptation system architecture. The grey components are what
    \sysname{} provides.}
  \label{fig:runtime}
\end{figure}

At runtime, the user program is automatically converted to a client half and
server half; and \sysname{} abstracts the communication as well as rate
adaptation. \autoref{fig:runtime} shows our runtime architecture.

The data source with degradation is a module that supports \texttt{update}
function. To handle insufficient bandwidth, an object-level queue bridges data
generation (source) and the network IO. Followed by the queue is a socket module
that abstracts the network communication. It transmits data as fast as possible
and also supports traffic probing. The growth of the queue indicates congestions
and will trigger the congestion controller. The socket module estimates actual
available bandwidth. To avoid spikes in the bandwidth measurement, exponential
smoothing is employed.

The congestion controller (\autoref{fig:cc}) similar to the bottleneck congestion
control~\cite{cardwell2017bbr}. Different from the pacing used in BBR, our
system directly matches the data rate with measured bottleneck bandwidth. In the
probing phase, to achieve a fine-granularity, the congestion controller inserts
additional dummy packets for the purpose of probing additional bandwidth. When
the congestion is resolved.

\begin{figure}
  \centering
  \resizebox{\columnwidth}{!}{
    \input{congestion-control}
  }
  \caption{Congestion Control Algorithm}
  \label{fig:cc}
\end{figure}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "sosp17"
%%% End:
